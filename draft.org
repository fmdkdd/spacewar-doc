# Draft of articles documenting Spacewar.

* Rationale
  Creating a full-fledged video game is an entertaining way to learn
  new languages, new libraries, and tackle moderately challenging
  problems. The more complex the game's rules and features, the harder
  the problems to solve on the way. In Spacewar for instance, the play
  field was initially a simple rectangular map. Rather quickly
  however, running into the map borders was frustrating the players,
  thus the map was changed to a tore. Having to wrap objects around
  the map is easy to handle, but doing so seamlessly as to not
  distract the player requires more ingenuity. Once you add collisions
  detection around the map borders, then the problem gets really
  interesting.

  Solving such problems in a game setting is satisfying because every
  time you do so, you can jump into the game and enjoy a new feature or
  one less bug, leading to a more enjoyable experience. Besides, some
  problems may lead to elegant solutions, and those are rewarding on
  their own.

  The idea behind Spacewar was to make an engaging multiplayer browser
  game in a space setting, leveraging current Web standards
  developments. Being a browser game, it follows a minimalistic design
  philosophy in order to accommodate the short attention span of the
  medium. This minimalism is perceptible even in the game pitch, which
  fit in one line:

  #+BEGIN_QUOTE
  "You are in space. Shoot other ships before they shoot you."
  #+END_QUOTE

  Similarly, the graphics are voluntarily bare, as to let players
  focus on gameplay, rather than fancy visual effects. This decision
  also bears the advantage of not requiring strong graphical skills,
  which we do not possess. Furthermore, the space setting can be used
  as an excuse for not having any sounds or music. Though it does not
  imply that every aspect of the game can be justified by the physical
  laws of space. This is still a video game, and one bereft of any
  pretension other than unadulterated fun.

  The multiplayer aspect of the game was justified by at least two
  reasons. Firstly, playing a game with human opponents is more
  engaging than a solitary game, or than a game played against
  computer AIs. Game AIs have a tendency to be predictable at best,
  and laughable at worst. While having a fearful AI in the game is a
  very inspiring problem in itself, we wanted to entertain human
  players first. Since designing the game mechanics and an AI at the
  same time could lead to compromises in gameplay to fit the AI
  capabilities, we decided to favor the mechanics and to take
  advantage of humans' adaptability. The second reason to have
  multiplayer was to get acquainted with the WebSocket protocol, part
  of the HTML5 working standard. This recent development of web
  technologies allows stable and efficient bidirectional communication
  between a browser and a server over the HTTP protocol. A multiplayer
  game involves frequent communications between clients and the
  server: more than fifty updates are broadcasted to clients every
  second. Therefore, a frantic multiplayer game with WebSockets would
  stand as a strong testimony of the protocol robustness.

  [Transition]

* Other works
  - Lazeroids
  - Rawkets
  - Swarmnation
  - Lichess

* The technology behind Spacewar

** HTML5 standard

*** JavaScript
    JavaScript is the programming language of web browsers. It started
    off as a modest scripting language used to enhance the
    possibilities of web designers in the mid 90's. Although it became
    widely adopted by websites, it was not overly popular with
    visitors who came to associate JavaScript with cascading popups
    windows and obnoxious animations. The language gained recognition
    in recent years, with the advent of Ajax techniques and the
    maturity of JavaScript frameworks and libraries such as jQuery,
    CommonJS, or ..? Most websites today use JavaScript in a variety
    of ways: to add visual effects to their design (essentially
    animations for a more dynamic web), to enhance the site
    accessibility (visual and oral clues to help visitors with
    disabilities), or to offer a more solid user interface for web
    applications (as in most major webmail providers).

    Fifteen years after its inception, the language has grown to offer
    a wide array of features, for professional and amateurs
    programmers alike. Some of those features were inspired by the
    Scheme language, notably the first-class functions, weak typing
    and closures. The Self language was an other parent, providing the
    prototype-based inheritance. Although both [verify] are
    idealistic, clean languages, JavaScript syntax is akin to the C
    and Java family. A convenient choice, since these are still the
    most popular programming languages, and their syntax is widely
    recognized by coders of all backgrounds. One last prominent[?]
    feature of the language is its capability for asynchronous
    programming without explicit thread handling. Any function can be
    scheduled for a later execution, without blocking the program
    flow. All the thread management is handled behind the scene by the
    virtual machine running the program, typically hosted by the web
    browser. This allows event-driven and concurrent applications to
    be easily written, since the facilities are built-in.

    Still, like every programming language, JavaScript has its
    downsides. While some are due to historical reasons, notably an
    initial implementation in 10 days by its creator, others are
    deliberate design choices. For instance, declaration of global
    variables is implicit, which can be the source of insidious errors
    for unaware programmers.

    #+BEGIN_CODE
    var foo;
    function f() {
       foo = 1;
       bar = 2;
       // do something with foo and bar
    }
    f();
    // foo is 1, bar is 2
    #+END_CODE

    In this code snippet, foo is a global declared in the global
    scope, but bar is also a global, although implicitly declared in
    the scope of f. Another quirky language feature are the "==" and
    "!=" operators which, like in PHP, do implicit type coercion. On
    top of being inefficient (strings have to be converted for numbers
    or vice-versa), this coercion voids the transitivity of
    equality. The following example illustrates this problem:

    #+BEGIN_CODE
    "" == 0   // true
    0 == "0"  // true
    "" == "0" // false
    #+END_CODE
    
    Fortunately, strict equality (and inequality) operators are also
    provided and behave rationally.
    
    In light of these peculiarities, seasoned JavaScript programmers
    established a guideline of recommended JavaScript style which
    emphasize clear and safe JavaScript programming practices [ref JS
    Garden, Elements of Style]. Popular frameworks also tend to
    enforce these practices and have their users follow them in order
    to avoid errors that are hard to track. Another solution to
    alleviate these downsides is to use another syntax that compiles
    directly into JavaScript, bypassing the error-prone features.

    CoffeeScript is a language by Jeremy Ashkenas [ref] that does just
    that. It compiles directly into JavaScript without any overhead at
    run-time. CoffeeScript borrows its syntax from Ruby, another
    popular programming language in the web development
    community. This translates into a cleaner syntax with optional
    parentheses, where indentation delimit blocks and functions
    instead of accolades. In addition, CoffeeScript provides syntactic
    sugar for idiomatic operations like iterating over an object
    properties, array comprehensions, and lambda function declaration.
    Consequently, CoffeeScript code is more expressive than the
    operationally equivalent JavaScript code, and time is gained both
    when programming and reading CoffeeScript code.
    
    Even though Spacewar began by using JavaScript, the decision to
    switch to CoffeeScript was easy to make for all the preceding
    reasons.
    
*** Canvas
    - HTML element designed for drawing
    - 2d/3d context with bare operations
    - Hardware acceleration (chrome)
    
*** SVG
    - Vector graphics

*** WebSocket
    - Older, inefficient alternatives (Long polling)
    - Like TCP, with added security and stability
    - API
    - Protocol

** Node.js
   - Designed for efficient and easy concurrency for server apps
   - Immature, but growing
   - Tons of modules

** Socket.IO
   - Module of node
   - Handles every technique in the book for establishing
     bi-directional communication

* Inner workings

** Overview
   - Server handles logic, communication
   - Client gathers input and draws

** Game logic

*** Update loop
    - Move
    - Check collisions
    - Update

*** Collisions
    - Spatial hashing
    - Symmetrical treatment

** Client-server communication
   - Keeping objects in sync
   - Minimizing communication overhead

*** Handling connections
*** Handling messages
*** Handling disconnections

** Drawing
   - DrawInfinity infinite tricks
   - Out of view checks
   - Clipping, double buffering

* History
** Websocket/PHP prototype

* Future improvements
 - Allow thousand game instances running on server cluster
 - Optimize client drawing
 - Optimize server update
 - Enhance compatibility with older browsers
 - Compatibility with touch devices

* Acknowledgments
  - Adrien, David, Thibaut for the spark
  - Merwan for the gas
  - Bertelle, Duvallet, Sanlaville.

* Links
** WebSocket Protocol
  - [[http://tools.ietf.org/html/rfc6202][Known Issues and Best Practices for Long Polling]], April 2011
  - [[http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07][The WebSocket protocol standards draft]], April 22, 2011
  - [[http://dev.w3.org/html5/websockets/][The WebSocket API]], May 21, 2011

** HTML5 drawing
  - [[http://webstuff.nfshost.com/anim-timing/Overview.html][Timing control for script-based animations]], February 22, 2011

** HTML5 book
   http://diveintohtml5.org/

** HTM5 Polyfills
   https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
