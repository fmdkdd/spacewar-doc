# Draft of articles documenting Spacewar.

* Rationale
  Creating a full-fledged video game is an entertaining way to learn
  new languages, new libraries, and tackle moderately challenging
  problems. The more complex the game's rules and features, the harder
  the problems to solve on the way. In Spacewar for instance, the play
  field was initially a simple rectangular map. Rather quickly
  however, running into the map borders was frustrating the players,
  thus the map was changed to a tore. Having to wrap objects around
  the map is easy to handle, but doing so seamlessly as to not
  distract the player requires more ingenuity. Once you add collisions
  detection around the map borders, then the problem gets really
  interesting.

  Solving such problems in a game setting is satisfying because every
  time you do so, you can jump into the game and enjoy a new feature or
  one less bug, leading to a more enjoyable experience. Besides, some
  problems may lead to elegant solutions, and those are rewarding on
  their own.

  The idea behind Spacewar was to make an engaging multiplayer browser
  game in a space setting, leveraging current Web standards
  developments. Being a browser game, it follows a minimalistic design
  philosophy in order to accommodate the short attention span of the
  medium. This minimalism is perceptible even in the game pitch, which
  fit in one line:

  #+BEGIN_QUOTE
  "You are in space. Shoot other ships before they shoot you."
  #+END_QUOTE

  Similarly, the graphics are voluntarily bare, as to let players
  focus on gameplay, rather than fancy visual effects. This decision
  also bears the advantage of not requiring strong graphical skills,
  which we do not possess. Furthermore, the space setting can be used
  as an excuse for not having any sounds or music. Though it does not
  imply that every aspect of the game can be justified by the physical
  laws of space. This is still a video game, and one bereft of any
  pretension other than unadulterated fun.

  The multiplayer aspect of the game was justified by at least two
  reasons. Firstly, playing a game with human opponents is more
  engaging than a solitary game, or than a game played against
  computer AIs. Game AIs have a tendency to be predictable at best,
  and laughable at worst. While having a fearful AI in the game is a
  very inspiring problem in itself, we wanted to entertain human
  players first. Since designing the game mechanics and an AI at the
  same time could lead to compromises in gameplay to fit the AI
  capabilities, we decided to favor the mechanics and to take
  advantage of humans' adaptability. The second reason to have
  multiplayer was to get acquainted with the WebSocket protocol, part
  of the HTML5 working standard. This recent development of web
  technologies allows stable and efficient bidirectional communication
  between a browser and a server over the HTTP protocol. A multiplayer
  game involves frequent communications between clients and the
  server: more than fifty updates are broadcasted to clients every
  second. Therefore, a frantic multiplayer game with WebSockets would
  stand as a strong testimony of the protocol robustness.

  [Transition]

* Other works
  - Lazeroids
  - Rawkets
  - Swarmnation
  - Lichess

* The technology behind Spacewar

** HTML5 standard

*** JavaScript
    JavaScript is the programming language of web browsers. Introduced
    by Netscape for their Navigator, it started off as a modest
    scripting language used to enhance the possibilities of web
    designers in the mid 90's. Although it became widely adopted by
    websites, it was not overly popular with visitors who came to
    associate JavaScript with cascading pop-ups windows and obnoxious
    animations. The language gained recognition in recent years, with
    the advent of Ajax techniques and the maturity of JavaScript
    frameworks and libraries such as jQuery, CommonJS, or [?]. Most
    websites today use JavaScript in a variety of ways: to add visual
    effects to their design (essentially animations for a more dynamic
    web), to enhance the site accessibility (visual and oral clues to
    help visitors with disabilities), or to offer a more solid user
    interface for web applications (as in most major webmail
    providers).

    Fifteen years after its inception, the language has grown to offer
    a wide array of features, for professional and amateurs
    programmers alike. Some of those features were inspired by the
    Scheme language, notably the first-class functions, weak typing
    and closures. The Self language was an other parent, providing the
    prototype-based inheritance. Although both are idealistic, clean
    languages, JavaScript syntax is akin to the C and Java family. A
    convenient choice, since these are still the most popular
    programming languages, and their syntax is widely recognized by
    coders of all backgrounds. One last prominent feature of the
    language is its capability for asynchronous programming without
    explicit thread handling. Any function can be scheduled for a
    later execution, without blocking the program flow. All the thread
    management is handled behind the scene by the virtual machine
    running the program, typically hosted by the web browser. This
    allows event-driven and concurrent applications to be easily
    written, since the facilities are built-in.

    Still, like every programming language, JavaScript has its
    downsides. While some are due to historical reasons, notably an
    initial implementation in 10 days by its creator, Brendan Eich,
    others are deliberate design choices. For instance, declaration of
    global variables is implicit, which can be the source of insidious
    errors for unaware programmers.

    #+BEGIN_SRC espresso
      var foo;
      function f() {
         foo = 1;
         bar = 2;
         // do something with foo and bar
      }
      f();
      // foo is 1, bar is 2
    #+END_SRC

    In this code snippet, foo is a global declared in the global
    scope, but bar is also a global, although implicitly declared in
    the scope of f. Another quirky language feature are the "==" and
    "!=" operators which, like in PHP, do implicit type coercion. On
    top of being inefficient (strings have to be converted for numbers
    or vice versa), this coercion voids the transitivity of
    equality. The following example illustrates this problem:

    #+BEGIN_SRC espresso
      "" == 0   // true
      0 == "0"  // true
      "" == "0" // false
    #+END_SRC
    
    Fortunately, strict equality (and inequality) operators are also
    provided and behave rationally.
    
    In light of these peculiarities, seasoned JavaScript programmers
    established a guideline of recommended JavaScript style which
    emphasize clear and safe JavaScript programming practices [ref JS
    Garden, Elements of Style]. Popular frameworks also tend to
    enforce these practices and have their users follow them in order
    to avoid errors that are hard to track. Another solution to
    alleviate these downsides is to use another syntax that compiles
    directly into JavaScript, bypassing the error-prone features.

    CoffeeScript is a language by Jeremy Ashkenas [ref] that does just
    that. It compiles directly into JavaScript without any overhead at
    run-time. CoffeeScript borrows its syntax from Ruby [ref], another
    popular programming language in the web development
    community. This translates into a cleaner syntax with optional
    parentheses, where indentation delimit blocks and functions
    instead of accolades. In addition, CoffeeScript provides syntactic
    sugar for idiomatic operations like iterating over an object
    properties, array comprehensions, and lambda function declaration.
    Consequently, CoffeeScript code is more expressive than the
    operationally equivalent JavaScript code, and time is gained both
    when programming and reading CoffeeScript code.
    
    Even though Spacewar began by using JavaScript, the decision to
    switch to CoffeeScript was easy to make for all the preceding
    reasons.
    
*** WebSocket
    The major part of Spacewar is its multiplayer aspect: having
    multiple players participating in the same game, each using a
    different browser on their own computer. This is enabled by the
    introduction of WebSockets to HTML5.

    The HTTP protocol was conceived as a unidirectional protocol: from
    the client to the server. The server can not initiate an
    unsolicited connection with a client, and is only allowed to send
    data to the client in response to a previous request from the
    client. Yet, asynchronous updates from the server have become a
    major part of today's web browsing. The usual solution is to abuse
    the protocol in part, by having the client frequently poll the
    server for updates. Typically, the client would send a request to
    the server every two seconds, and the server would respond with
    update data, or with an empty response if no update occurred. This
    is a simple way to provide the illusion of asynchronous updates,
    but it comes at a price. 

    To receive update in a timely fashion, the polling frequency
    should be short, around 5 seconds. This means that every 5
    seconds, a HTTP request is sent to the server, and a response is
    received. Sending a new HTTP request requires establishing a TCP
    connection with the server, and that in turn takes some round
    trips between the client and the server. In addition, the request
    and response have to contain HTTP headers that add to the packets'
    size, though the information they transmit is mostly the same each
    time. This short polling technique is thus very inefficient, as
    not only time is wasted by setting up a full TCP communication
    each time, but bandwidth is also squandered.

    To alleviate these problems, more refined techniques have come to
    light. The two most common mechanisms are known as HTTP long
    polling and HTTP streaming. Both are described RFC 6202 [ref]. As
    the name implies, long polling consists of sending a request to
    the server, who will delay its response until there is data to
    transmit. When the client receives the response, it immediately
    sends a new request for the next update. In HTTP streaming, the
    server sends its response in parts, thus keeping the connection
    with the client alive, until its renewal after a set amount of
    time. While more efficient than short polling, both have
    disadvantages over a straightforward TCP socket. When renewing the
    long poll request or stream, messages can not be sent from the
    server, and must thus be buffered until the connection is
    established. Other difficulties may arise when intermediaries
    (proxies, gateways) are present between the client and the
    server, as they may decide to cache the server responses, thus
    defeating the mechanism. Best practices for implementing these
    techniques are described in the RFC.

    A better solution is to augment the HTTP protocol, allowing true,
    persistent bi-directional communication without much
    overhead. That is precisely the high-level description of the
    WebSocket protocol [ref]. This protocol consists of establishing a
    TCP connection between a client and a server, allowing two-way
    message passing after an HTTP handshake part. Using the HTTP
    request/response model, both client and server acknowledge of an
    "HTTP upgrade" to use the WebSocket protocol. Once they agree,
    messages can be freely sent between both entities until the
    connection is closed. In addition to the TCP connection, the
    WebSocket protocol provides:

    #+BEGIN_QUOTE
    - a Web "origin"-based security model for browsers;
    - an addressing and protocol naming mechanism to support multiple
    services on one port and multiple host names on one IP address;
    - a framing mechanism on top of TCP to get back to the IP
    packet mechanism that TCP is built on, but without length limits.
    #+END_QUOTE

    The WebSocket protocol enforces the same origin policy commonly
    used in web browsers. Basically, WebSockets established between a
    browser and a web server at http://www.foo.com/ can only be
    accessed by scripts running for a page from a server with the same
    domain. Scripts from other domains do not have legitimate access
    to resources (scripts, sockets) of others.

    The WebSocket API offered to web browsers scripts is rather
    straightforward, and event-based. In simple setups, the client
    only has to create a WebSocket object, then register function
    callbacks for the following events: connection open, message
    received, connection closed. The WebSocket object can be used to
    send messages to the server, and to close the connection. Messages
    can either be sent as UTF-8 strings or as raw binary.

    [closure?]

*** Canvas
    The canvas HTML element is an important part of HTML5. It was
    initially created by Apple for Safari and the Mac OS X Dashboard,
    but is now implemented in all the major web browsers [fn:: By
    major web browsers, we mean Firefox, Chrome, Internet Explorer,
    Safari and Opera.]

    The intent is to provide an area on web pages upon which to draw
    freely, as an alternative to vector graphics provided by SVG
    (Scalable Vector Graphics). While SVG already allowed scripted
    animations to be run freely on web pages since its initial release
    in 2001, SVG images have to be inserted into the DOM tree, and
    this can be a significant computation overhead if lots of SVG
    images are inserted and removed from the DOM tree. When fast
    animations are required, this overhead is unacceptable. Being a
    single DOM element, the canvas provides a potentially faster way
    to draw animation than SVG. But these two graphics solutions are
    not interchangeable.

    First, the canvas is bitmap-based. This means that graphics drawn
    on the canvas are resolution dependent, whereas SVG animations are
    freely scalable. Bitmap graphics are faster to process, thus well
    suited to animations that require a high number of frames every
    second, like games. Scalable graphics are great for everything
    else, since they do not degrade in image quality when zoomed at
    any size.

    The canvas element also has the ability to use a 3d rendering
    context, enabling OpenGL applications to be embedded in web pages
    and rendered using a software OpenGL implementation, or even a
    hardware one if the proper driver is present. Implementations of
    this 3d context in major browsers is ongoing. The latest Firefox,
    Chrome, Safari and Opera browsers support WebGL, but not on all
    platforms. Besides, since calling the GPU driver directly can lead
    to crashes unrelated with the browser itself (caused by faulty
    drivers or poor graphics management in the OS), WebGL support can
    be deactivated by default in some browsers, or for unsupported
    hardware. Nonetheless, some demonstrative applications already
    exist, with the most impressive being ports of famous 3d games
    like this Quake 3 level loader [ref] or this interactive film by
    Chris Milk [ref].
    
    Finally, should web applications using canvas require even more
    processing power for their animations, major browsers are
    beginning to provide hardware acceleration even for the 2d drawing
    context. This is also optional and enabled client-side, due to the
    stability issues mentioned above, but still is a nice option to
    have.

    The consequence of providing all those facilities to web scripts,
    both versatile with SVG and powerful with the canvas element, is
    the diminishing need for proprietary alternatives like Adobe Flash
    or Microsoft Silverlight. A few year back, Adobe Flash was the de
    facto standard for web animations. Today, with browsers adopting
    HTML5 standard and especially the canvas element, animations can
    both be fast and portable. Furthermore, the specification is fully
    open, as are implementations in most browsers.
      
    Spacewar makes full use of the canvas element. All the game is
    currently drawn on it, and it fills the entire web page. Some SVG
    images are also used for the configuration menu.

** Node.js
   - Designed for efficient and easy concurrency for server apps
   - Immature, but growing
   - Tons of modules

** Socket.IO
   - Module of node
   - Handles every technique in the book for establishing
     bi-directional communication
     
* Inner workings

** Overview
   - Server handles logic, communication
   - Client gathers input and draws

** Game logic

*** Update loop
    - Move
    - Check collisions
    - Update

*** Collisions
    - Spatial hashing
    - Symmetrical treatment

** Client-server communication
   - Keeping objects in sync
   - Minimizing communication overhead

*** Handling connections
*** Handling messages
*** Handling disconnections

** Drawing
   - DrawInfinity infinite tricks
   - Out of view checks
   - Clipping, double buffering

* History
** Websocket/PHP prototype

* Future improvements
 - Allow thousand game instances running on server cluster
 - Optimize client drawing
 - Optimize server update
 - Enhance compatibility with older browsers
 - Compatibility with touch devices

* Acknowledgments
  - Adrien, David, Thibaut for the spark
  - Merwan for the gas
  - Bertelle, Duvallet, Sanlaville.

* Links
** JavaScript
   - [[https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml][Google JavaScript Style Guide]], Aaron Whyte et al.
   - [[http://bonsaiden.github.com/JavaScript-Garden/][JavaScript Garden]], Ivo Wetzel and Zhang Yi Jiang, 2011.
   - [[http://coffeescript.org/][CoffeeScript]], Jeremy Ashkenas.

** WebSocket Protocol
  - [[http://tools.ietf.org/html/rfc6202][Known Issues and Best Practices for Long Polling]], April 2011
  - [[http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07][The WebSocket protocol standards draft]], April 22, 2011
  - [[http://dev.w3.org/html5/websockets/][The WebSocket API]], May 21, 2011

** HTML5 drawing
  - [[http://webstuff.nfshost.com/anim-timing/Overview.html][Timing control for script-based animations]], February 22, 2011
  - [[http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element][HTML Standard: the canvas element]], May 27, 2011
  - [[http://www.khronos.org/registry/webgl/specs/latest/#7][WebGL Specification]], May 25, 2011
  - [[http://media.tojicode.com/q3bsp/][Quake 3 WebGL Demo]], Brandon Jones.
  - [[http://www.ro.me][ROME, "3 Dreams of Black"]], Chris Milk.

** HTML5 book
   http://diveintohtml5.org/

** HTM5 Polyfills
   https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
