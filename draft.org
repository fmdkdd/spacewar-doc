# Draft of articles documenting Spacewar.

* Rationale
  Creating a full-fledged video game is an entertaining way to learn
  new languages, new libraries, and tackle moderately challenging
  problems. The more complex the game's rules and features, the harder
  the problems to solve on the way. In Spacewar for instance, the play
  field was initially a simple rectangular map. Rather quickly
  however, running into the map borders was frustrating the players,
  thus the map was changed to a tore. Having to wrap objects around
  the map is easy to handle, but doing so seamlessly as to not
  distract the player requires more ingenuity. Once you add collisions
  detection around the map borders, then the problem gets really
  interesting.

  Solving such problems in a game setting is satisfying because every
  time you do so, you can jump into the game and enjoy a new feature or
  one less bug, leading to a more enjoyable experience. Besides, some
  problems may lead to elegant solutions, and those are rewarding on
  their own.

  The idea behind Spacewar was to make an engaging multiplayer browser
  game in a space setting, leveraging current Web standards
  developments. Being a browser game, it follows a minimalistic design
  philosophy in order to accommodate the short attention span of the
  medium. This minimalism is perceptible even in the game pitch, which
  fit in one line:

  #+BEGIN_QUOTE
  "You are in space. Shoot other ships before they shoot you."
  #+END_QUOTE

  Similarly, the graphics are voluntarily bare, as to let players
  focus on gameplay, rather than fancy visual effects. This decision
  also bears the advantage of not requiring strong graphical skills,
  which we do not possess. Furthermore, the space setting can be used
  as an excuse for not having any sounds or music. Though it does not
  imply that every aspect of the game can be justified by the physical
  laws of space. This is still a video game, and one bereft of any
  pretension other than unadulterated fun.

  The multiplayer aspect of the game was justified by at least two
  reasons. Firstly, playing a game with human opponents is more
  engaging than a solitary game, or than a game played against
  computer AIs. Game AIs have a tendency to be predictable at best,
  and laughable at worst. While having a fearful AI in the game is a
  very inspiring problem in itself, we wanted to entertain human
  players first. Since designing the game mechanics and an AI at the
  same time could lead to compromises in gameplay to fit the AI
  capabilities, we decided to favor the mechanics and to take
  advantage of humans' adaptability. The second reason to have
  multiplayer was to get acquainted with the WebSocket protocol, part
  of the HTML5 working standard. This recent development of web
  technologies allows stable and efficient bidirectional communication
  between a browser and a server over the HTTP protocol. A multiplayer
  game involves frequent communications between clients and the
  server: more than fifty updates are broadcasted to clients every
  second. Therefore, a frantic multiplayer game with WebSockets would
  stand as a strong testimony of the protocol robustness.

  [Transition]

* Other works
  - Lazeroids
  - Rawkets
  - Swarmnation
  - Lichess

* The technology behind Spacewar

** HTML5 standard

*** JavaScript
    JavaScript is the programming language of web browsers. It started
    off as a modest scripting language used to enhance the
    possibilities of web designers in the mid 90's. Although it became
    widely adopted by websites, it was not overly popular with
    visitors who came to associate JavaScript with cascading pop-ups
    windows and obnoxious animations. The language gained recognition
    in recent years, with the advent of Ajax techniques and the
    maturity of JavaScript frameworks and libraries such as jQuery,
    CommonJS, or [?] Most websites today use JavaScript in a variety
    of ways: to add visual effects to their design (essentially
    animations for a more dynamic web), to enhance the site
    accessibility (visual and oral clues to help visitors with
    disabilities), or to offer a more solid user interface for web
    applications (as in most major webmail providers).

    Fifteen years after its inception, the language has grown to offer
    a wide array of features, for professional and amateurs
    programmers alike. Some of those features were inspired by the
    Scheme language, notably the first-class functions, weak typing
    and closures. The Self language was an other parent, providing the
    prototype-based inheritance. Although both [verify] are
    idealistic, clean languages, JavaScript syntax is akin to the C
    and Java family. A convenient choice, since these are still the
    most popular programming languages, and their syntax is widely
    recognized by coders of all backgrounds. One last prominent
    feature of the language is its capability for asynchronous
    programming without explicit thread handling. Any function can be
    scheduled for a later execution, without blocking the program
    flow. All the thread management is handled behind the scene by the
    virtual machine running the program, typically hosted by the web
    browser. This allows event-driven and concurrent applications to
    be easily written, since the facilities are built-in.

    Still, like every programming language, JavaScript has its
    downsides. While some are due to historical reasons, notably an
    initial implementation in 10 days by its creator, others are
    deliberate design choices. For instance, declaration of global
    variables is implicit, which can be the source of insidious errors
    for unaware programmers.

    #+BEGIN_CODE
    var foo;
    function f() {
       foo = 1;
       bar = 2;
       // do something with foo and bar
    }
    f();
    // foo is 1, bar is 2
    #+END_CODE

    In this code snippet, foo is a global declared in the global
    scope, but bar is also a global, although implicitly declared in
    the scope of f. Another quirky language feature are the "==" and
    "!=" operators which, like in PHP, do implicit type coercion. On
    top of being inefficient (strings have to be converted for numbers
    or vice-versa), this coercion voids the transitivity of
    equality. The following example illustrates this problem:

    #+BEGIN_CODE
    "" == 0   // true
    0 == "0"  // true
    "" == "0" // false
    #+END_CODE
    
    Fortunately, strict equality (and inequality) operators are also
    provided and behave rationally.
    
    In light of these peculiarities, seasoned JavaScript programmers
    established a guideline of recommended JavaScript style which
    emphasize clear and safe JavaScript programming practices [ref JS
    Garden, Elements of Style]. Popular frameworks also tend to
    enforce these practices and have their users follow them in order
    to avoid errors that are hard to track. Another solution to
    alleviate these downsides is to use another syntax that compiles
    directly into JavaScript, bypassing the error-prone features.

    CoffeeScript is a language by Jeremy Ashkenas [ref] that does just
    that. It compiles directly into JavaScript without any overhead at
    run-time. CoffeeScript borrows its syntax from Ruby, another
    popular programming language in the web development
    community. This translates into a cleaner syntax with optional
    parentheses, where indentation delimit blocks and functions
    instead of accolades. In addition, CoffeeScript provides syntactic
    sugar for idiomatic operations like iterating over an object
    properties, array comprehensions, and lambda function declaration.
    Consequently, CoffeeScript code is more expressive than the
    operationally equivalent JavaScript code, and time is gained both
    when programming and reading CoffeeScript code.
    
    Even though Spacewar began by using JavaScript, the decision to
    switch to CoffeeScript was easy to make for all the preceding
    reasons.
    
*** Canvas
    The canvas HTML element is an important part of HTML5. It was
    initially created by Apple for Safari and the Mac OS X Dashboard,
    but is now implemented in all the major web browsers.

    The intent is to provide an area on web pages upon which to draw
    freely, as an alternative to vector graphics provided by SVG
    (Scalable Vector Graphics). While SVG already allowed scripted
    animations to be run freely on web pages since its initial release
    in 2001, SVG images have to be inserted into the DOM tree, and
    this can be a significant computation overhead if lots of SVG
    images are inserted and removed from the DOM tree. When fast
    animations are required, this overhead is unacceptable. Being a
    single DOM element, the canvas provides a potentially faster way
    to draw animation than SVG. But these two graphics solutions are
    not interchangeable.

    First, the canvas is bitmap-based. This means that graphics drawn
    on the canvas are resolution dependent, whereas SVG animations are
    freely scalable. Bitmap graphics are faster to process, thus well
    suited to animations that require a high number of frames every
    second, like games. Scalable graphics are great for everything
    else, since they do not degrade in image quality when zoomed at
    any size.

    The canvas element also has the ability to use a 3d rendering
    context, enabling OpenGL applications to be embedded in web pages
    and rendered using a software OpenGL implementation, or even a
    hardware one if the proper driver is present. Implementations of
    this 3d context in major browsers is ongoing. The latest Firefox,
    Chrome, Safari and Opera browsers support WebGL, but not on all
    platforms. Besides, since calling the GPU driver directly can lead
    to crashes unrelated with the browser itself (caused by faulty
    drivers or poor graphics management in the OS), WebGL support is
    deactivated by default in most browsers. Nonetheless, some
    demonstrative applications already exist, with the most impressive
    ports of famous 3d games like Quake 3 [ref] or Doom [ref].
    
    Finally, should web applications using canvas require even more
    processing power for their animations, major browsers are
    beginning to provide hardware acceleration even for the 2d drawing
    context. This is also optional and enabled client-side, due to the
    stability issues mentioned above, but still is a nice option to
    have.

    The consequence of providing all those facilities to web scripts,
    both versatile with SVG and powerful with the canvas element, is
    the diminishing need for proprietary alternatives like Adobe Flash
    or Microsoft Silverlight. A few year back, Adobe Flash was the de
    facto standard for web animations. Today, with browsers adopting
    HTML5 standard and especially the canvas element, animations can
    both be fast and portable. Furthermore, the specification is fully
    open, as are implementations in most browsers.
      
    Spacewar makes full use of the canvas element. All the game is
    currently drawn on it, and it fills the entire web page. Some SVG
    images are also used for the configuration menu.
    
*** WebSocket
    - Older, inefficient alternatives (Long polling)
    - Like TCP, with added security and stability
    - API
    - Protocol

** Node.js
   - Designed for efficient and easy concurrency for server apps
   - Immature, but growing
   - Tons of modules

** Socket.IO
   - Module of node
   - Handles every technique in the book for establishing
     bi-directional communication
     
* Inner workings

** Overview
   - Server handles logic, communication
   - Client gathers input and draws

** Game logic

*** Update loop
    - Move
    - Check collisions
    - Update

*** Collisions
    - Spatial hashing
    - Symmetrical treatment

** Client-server communication
   - Keeping objects in sync
   - Minimizing communication overhead

*** Handling connections
*** Handling messages
*** Handling disconnections

** Drawing
   - DrawInfinity infinite tricks
   - Out of view checks
   - Clipping, double buffering

* History
** Websocket/PHP prototype

* Future improvements
 - Allow thousand game instances running on server cluster
 - Optimize client drawing
 - Optimize server update
 - Enhance compatibility with older browsers
 - Compatibility with touch devices

* Acknowledgments
  - Adrien, David, Thibaut for the spark
  - Merwan for the gas
  - Bertelle, Duvallet, Sanlaville.

* Links
** JavaScript
   - [[http://javascript.crockford.com/code.html][Code Conventions for the JavaScript Programming Language]], Douglas
     Crockford, 20??
   - [[http://bonsaiden.github.com/JavaScript-Garden/][JavaScript Garden]], Ivo Wetzel and Zhang Yi Jiang, 2011.
   - [[http://coffeescript.org/][CoffeeScript]], Jeremy Ashkenas.

** WebSocket Protocol
  - [[http://tools.ietf.org/html/rfc6202][Known Issues and Best Practices for Long Polling]], April 2011
  - [[http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07][The WebSocket protocol standards draft]], April 22, 2011
  - [[http://dev.w3.org/html5/websockets/][The WebSocket API]], May 21, 2011

** HTML5 drawing
  - [[http://webstuff.nfshost.com/anim-timing/Overview.html][Timing control for script-based animations]], February 22, 2011
  - [[http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element][HTML Standard: the canvas element]], May 27, 2011
  - [[http://www.khronos.org/registry/webgl/specs/latest/#7][WebGL Specification]], May 25, 2011
  - [[http://media.tojicode.com/q3bsp/][Quake 3 WebGL Demo]], Brandon Jones.

** HTML5 book
   http://diveintohtml5.org/

** HTM5 Polyfills
   https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
