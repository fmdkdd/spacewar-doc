# Draft of articles documenting Spacewar.

* Rationale
  Creating a full-fledged video game is an entertaining way to learn
  new languages, new libraries, and tackle moderately challenging
  problems. The more complex the game's rules and features, the harder
  the problems to solve on the way. In Spacewar for instance, the play
  field was initially a simple rectangular map. Rather quickly
  however, running into the map borders was frustrating the players,
  thus the map was changed to a tore. Having to wrap objects around
  the map is easy to handle, but doing so seamlessly as to not
  distract the player requires more ingenuity. Once you add collisions
  detection around the map borders, then the problem gets really
  interesting.

  Solving such problems in a game setting is satisfying because every
  time you do so, you can jump into the game and enjoy a new feature or
  one less bug, leading to a more enjoyable experience. Besides, some
  problems may lead to elegant solutions, and those are rewarding on
  their own.

  The idea behind Spacewar was to make an engaging multiplayer browser
  game in a space setting, leveraging current Web standards
  developments. Being a browser game, it follows a minimalistic design
  philosophy in order to accommodate the short attention span of the
  medium. This minimalism is perceptible even in the game pitch, which
  fit in one line:

  #+BEGIN_QUOTE
  "You are in space. Shoot other ships before they shoot you."
  #+END_QUOTE

  Similarly, the graphics are voluntarily bare, as to let players
  focus on gameplay, rather than fancy visual effects. This decision
  also bears the advantage of not requiring strong graphical skills,
  which we do not possess. Furthermore, the space setting can be used
  as an excuse for not having any sounds or music. Though it does not
  imply that every aspect of the game can be justified by the physical
  laws of space. This is still a video game, and one bereft of any
  pretension other than unadulterated fun.

  The multiplayer aspect of the game was justified by at least two
  reasons. Firstly, playing a game with human opponents is more
  engaging than a solitary game, or than a game played against
  computer AIs. Game AIs have a tendency to be predictable at best,
  and laughable at worst. While having a fearful AI in the game is a
  very inspiring problem in itself, we wanted to entertain human
  players first. Since designing the game mechanics and an AI at the
  same time could lead to compromises in gameplay to fit the AI
  capabilities, we decided to favor the mechanics and to take
  advantage of humans' adaptability. The second reason to have
  multiplayer was to get acquainted with the WebSocket protocol, part
  of the HTML5 working standard. This recent development of web
  technologies allows stable and efficient bidirectional communication
  between a browser and a server over the HTTP protocol. A multiplayer
  game involves frequent communications between clients and the
  server: more than fifty updates are broadcasted to clients every
  second. Therefore, a frantic multiplayer game with WebSockets would
  stand as a strong testimony of the protocol robustness.

  [Transition]

* Other works
  - Lazeroids
  - Rawkets
  - Swarmnation
  - Lichess

* The technology behind Spacewar

** HTML5 standard
   
   [Some introduction on W3C/WHATWG]

*** JavaScript
    JavaScript is the programming language of web browsers. Introduced
    by Netscape for their Navigator, it started off as a modest
    scripting language used to enhance the possibilities of web
    designers in the mid 90's. Although it became widely adopted by
    websites, it was not overly popular with visitors who came to
    associate JavaScript with cascading pop-ups windows and obnoxious
    animations. The language gained recognition in recent years, with
    the advent of Ajax techniques and the maturity of JavaScript
    frameworks and libraries such as jQuery, CommonJS, or [?]. Most
    websites today use JavaScript in a variety of ways: to add visual
    effects to their design (essentially animations for a more dynamic
    web), to enhance the site accessibility (visual and oral clues to
    help visitors with disabilities), or to offer a more solid user
    interface for web applications (as in most major webmail
    providers).

    Fifteen years after its inception, the language has grown to offer
    a wide array of features, for professional and amateurs
    programmers alike. Some of those features were inspired by the
    Scheme language, notably the first-class functions, weak typing
    and closures. The Self language was an other parent, providing the
    prototype-based inheritance. Although both are idealistic, clean
    languages, JavaScript syntax is akin to the C and Java family. A
    convenient choice, since these are still the most popular
    programming languages, and their syntax is widely recognized by
    coders of all backgrounds. One last prominent feature of the
    language is its capability for asynchronous programming without
    explicit thread handling. Any function can be scheduled for a
    later execution, without blocking the program flow. All the thread
    management is handled behind the scene by the virtual machine
    running the program, typically hosted by the web browser. This
    allows event-driven and concurrent applications to be easily
    written, since the facilities are built-in.

    Still, like every programming language, JavaScript has its
    downsides. While some are due to historical reasons, notably an
    initial implementation in 10 days by its creator, Brendan Eich,
    others are deliberate design choices. For instance, declaration of
    global variables is implicit, which can be the source of insidious
    errors for unaware programmers.

    #+BEGIN_SRC espresso
      var foo;
      function f() {
         foo = 1;
         bar = 2;
         // do something with foo and bar
      }
      f();
      // foo is 1, bar is 2
    #+END_SRC

    In this code snippet, foo is a global declared in the global
    scope, but bar is also a global, although implicitly declared in
    the scope of f. Another quirky language feature are the "==" and
    "!=" operators which, like in PHP, do implicit type coercion. On
    top of being inefficient (strings have to be converted for numbers
    or vice versa), this coercion voids the transitivity of
    equality. The following example illustrates this problem:

    #+BEGIN_SRC espresso
      "" == 0   // true
      0 == "0"  // true
      "" == "0" // false
    #+END_SRC
    
    Fortunately, strict equality (and inequality) operators are also
    provided and behave rationally.
    
    In light of these peculiarities, seasoned JavaScript programmers
    established a guideline of recommended JavaScript style which
    emphasize clear and safe JavaScript programming practices [ref JS
    Garden, Elements of Style]. Popular frameworks also tend to
    enforce these practices and have their users follow them in order
    to avoid errors that are hard to track. Another solution to
    alleviate these downsides is to use another syntax that compiles
    directly into JavaScript, bypassing the error-prone features.

    CoffeeScript is a language by Jeremy Ashkenas [ref] that does just
    that. It compiles directly into JavaScript without any overhead at
    run-time. CoffeeScript borrows its syntax from Ruby [ref], another
    popular programming language in the web development
    community. This translates into a cleaner syntax with optional
    parentheses, where indentation delimit blocks and functions
    instead of accolades. In addition, CoffeeScript provides syntactic
    sugar for idiomatic operations like iterating over an object
    properties, array comprehensions, and lambda function declaration.
    Consequently, CoffeeScript code is more expressive than the
    operationally equivalent JavaScript code, and time is gained both
    when programming and reading CoffeeScript code.
    
    Even though Spacewar began by using JavaScript, the decision to
    switch to CoffeeScript was easy to make for all the preceding
    reasons.

*** Canvas
    The canvas HTML element is an important part of HTML5. It was
    initially created by Apple for Safari and the Mac OS X Dashboard,
    but is now implemented in all the major web browsers [fn:: By
    major web browsers, we mean Firefox, Chrome, Internet Explorer,
    Safari and Opera.]

    The intent is to provide an area on web pages upon which to draw
    freely, as an alternative to vector graphics provided by SVG
    (Scalable Vector Graphics). While SVG already allowed scripted
    animations to be run freely on web pages since its initial release
    in 2001, SVG images have to be inserted into the DOM tree, and
    this can be a significant computation overhead if lots of SVG
    images are inserted and removed from the DOM tree. When fast
    animations are required, this overhead is unacceptable. Being a
    single DOM element, the canvas provides a potentially faster way
    to draw animation than SVG. But these two graphics solutions are
    not interchangeable.

    First, the canvas is bitmap-based. This means that graphics drawn
    on the canvas are resolution dependent, whereas SVG animations are
    freely scalable. Bitmap graphics are faster to process, thus well
    suited to animations that require a high number of frames every
    second, like games. Scalable graphics are great for everything
    else, since they do not degrade in image quality when zoomed at
    any size.

    The canvas element also has the ability to use a 3d rendering
    context, enabling OpenGL applications to be embedded in web pages
    and rendered using a software OpenGL implementation, or even a
    hardware one if the proper driver is present. Implementations of
    this 3d context in major browsers is ongoing. The latest Firefox,
    Chrome, Safari and Opera browsers support WebGL, but not on all
    platforms. Besides, since calling the GPU driver directly can lead
    to crashes unrelated with the browser itself (caused by faulty
    drivers or poor graphics management in the OS), WebGL support can
    be deactivated by default in some browsers, or for unsupported
    hardware. Nonetheless, some demonstrative applications already
    exist, with the most impressive being ports of famous 3d games
    like this Quake 3 level loader [ref] or this interactive film by
    Chris Milk [ref].
    
    Finally, should web applications using canvas require even more
    processing power for their animations, major browsers are
    beginning to provide hardware acceleration even for the 2d drawing
    context. This is also optional and enabled client-side, due to the
    stability issues mentioned above, but still is a nice option to
    have.

    The consequence of providing all those facilities to web scripts,
    both versatile with SVG and powerful with the canvas element, is
    the diminishing need for proprietary alternatives like Adobe Flash
    or Microsoft Silverlight. A few year back, Adobe Flash was the de
    facto standard for web animations. Today, with browsers adopting
    HTML5 standard and especially the canvas element, animations can
    both be fast and portable. Furthermore, the specification is fully
    open, as are implementations in most browsers.
      
    Spacewar makes full use of the canvas element. All the game is
    currently drawn on it, and it fills the entire web page. Some SVG
    images are also used for the configuration menu.
    
*** WebSocket
    The major part of Spacewar is its multiplayer aspect: having
    multiple players participating in the same game, each using a
    different browser on their own computer. This is enabled by the
    introduction of WebSockets to HTML5.

    The HTTP protocol was conceived as a unidirectional protocol: from
    the client to the server. The server can not initiate an
    unsolicited connection with a client, and is only allowed to send
    data to the client in response to a previous request from the
    client. Yet, asynchronous updates from the server have become a
    major part of today's web browsing. The usual solution is to abuse
    the protocol in part, by having the client frequently poll the
    server for updates. Typically, the client would send a request to
    the server every two seconds, and the server would respond with
    update data, or with an empty response if no update occurred. This
    is a simple way to provide the illusion of asynchronous updates,
    but it comes at a price. 

    To receive update in a timely fashion, the polling frequency
    should be short, around 5 seconds. This means that every 5
    seconds, a HTTP request is sent to the server, and a response is
    received. Sending a new HTTP request requires establishing a TCP
    connection with the server, and that in turn takes some round
    trips between the client and the server. In addition, the request
    and response have to contain HTTP headers that add to the packets'
    size, though the information they transmit is mostly the same each
    time. This short polling technique is thus very inefficient, as
    not only time is wasted by setting up a full TCP communication
    each time, but bandwidth is also squandered.

    To alleviate these problems, more refined techniques have come to
    light. The two most common mechanisms are known as HTTP long
    polling and HTTP streaming. Both are described RFC 6202 [ref]. As
    the name implies, long polling consists of sending a request to
    the server, who will delay its response until there is data to
    transmit. When the client receives the response, it immediately
    sends a new request for the next update. In HTTP streaming, the
    server sends its response in parts, thus keeping the connection
    with the client alive, until its renewal after a set amount of
    time. While more efficient than short polling, both have
    disadvantages over a straightforward TCP socket. When renewing the
    long poll request or stream, messages can not be sent from the
    server, and must thus be buffered until the connection is
    established. Other difficulties may arise when intermediaries
    (proxies, gateways) are present between the client and the
    server, as they may decide to cache the server responses, thus
    defeating the mechanism. Best practices for implementing these
    techniques are described in the RFC.

    A better solution is to augment the HTTP protocol, allowing true,
    persistent bi-directional communication without much
    overhead. That is precisely the high-level description of the
    WebSocket protocol [ref]. This protocol consists of establishing a
    TCP connection between a client and a server, allowing two-way
    message passing after an HTTP handshake part. Using the HTTP
    request/response model, both client and server acknowledge of an
    "HTTP upgrade" to use the WebSocket protocol. Once they agree,
    messages can be freely sent between both entities until the
    connection is closed. In addition to the TCP connection, the
    WebSocket protocol provides:

    #+BEGIN_QUOTE
    - a Web "origin"-based security model for browsers;
    - an addressing and protocol naming mechanism to support multiple
    services on one port and multiple host names on one IP address;
    - a framing mechanism on top of TCP to get back to the IP
    packet mechanism that TCP is built on, but without length limits.
    #+END_QUOTE

    The WebSocket protocol enforces the same origin policy commonly
    used in web browsers. Basically, WebSockets established between a
    browser and a web server at http://www.foo.com/ can only be
    accessed by scripts running for a page from a server with the same
    domain. Scripts from other domains do not have legitimate access
    to resources (scripts, sockets) of others.

    The WebSocket API offered to web browsers scripts is rather
    straightforward, and event-based. In simple setups, the client
    only has to create a WebSocket object, then register function
    callbacks for the following events: connection open, message
    received, connection closed. The WebSocket object can be used to
    send messages to the server, and to close the connection. Messages
    can either be sent as UTF-8 strings or as raw binary.

    [closure?]

** Node
   Obviously, WebSocket support is required both on the client and on
   the server. On the client side, a check may be done when the game
   script executes to detect WebSocket support in the browser, and act
   accordingly. On the server front, the choice is more limited. The
   early prototype of Spacewar used a PHP implementation of the
   WebSocket protocol on the server [ref]. Back then, the server was
   only used to pass messages around between clients. All the game
   logic was handled by the clients themselves, and each client sent
   its state to all the others, via the server. It quickly became
   clear however that this PHP implementation of WebSocket was meant
   for trivial demonstrations purposes, but not for real applications.

   As a result of the WebSocket protocol being recent and not
   finalized, the number of implementations outside of web browser is
   not overwhelming, though sufficient. Although the protocol is not
   overly complicated, implementing it was beyond the scope of
   Spacewar. Besides, due to security concerns, the protocol is still
   evolving. An implementation that can stay up to date with current
   and future versions of the protocol is preferred. This essentially
   means that the chosen WebSocket implementation should be popular
   enough to ensure that it will be supported until at least the
   protocol finalization. A rapid search indicates there are already
   quite a few implementations for C, C#, Java, Ruby and JavaScript,
   and more. The JavaScript implementation is of particular interest,
   and was chosen for reasons we will now expose.

   First and foremost, since JavaScript was required for programming
   the client, having it as the server language helps promoting code
   reuse and consistency. The code is clearer as a result, since some
   client constructs are mirrored on the server.
   
   Secondly, the chosen JavaScript implementation of the WebSocket
   protocol is actually a module for a high-performance server
   back-end software running JavaScript code, called Node (or node.js)
   [ref]. At the core, Node is an abstraction of asynchronous I/O with
   a layer of web-oriented networking facilities designed for building
   scalable web servers. Under the hood Node is running Google's V8
   JavaScript engine, which allow users to program all their server
   code using only JavaScript, although Node itself is essentially
   C++.
   
   With the growing number of Internet users, it is not uncommon for
   web hosts serving popular content to handle a million or more daily
   hits, and a hundred thousand of simultaneous clients. Against such
   numbers, very efficient server software (and hardware) is required.
   The two main approaches for serving content at this rate in server
   software are multithreading and asynchronous (non-blocking)
   I/O. While allocating a thread for each client (or a group of
   clients) and retrieving content with blocking I/O in each thread is
   feasible, implementations of threads in most systems makes this
   solution sub-optimal. For one, managing ten thousand threads can
   become quite complex. In addition, the costs of thread allocating,
   context switching and scheduling hamper this method's scalability.

   On the other hand, asynchronous I/O is rather straightforward:
   instead of spawning a new lightweight process (thread) to read and
   send a file to the client, just wait for the system to signal the
   file readiness, and execute a callback function to read and send
   it. The cost of handling one more client is much lower than for
   multithreading, although not all non-blocking I/O mechanisms in the
   OS are equal. Hardware interrupts are favored, but might not be
   available, in which case the slower method of polling is used.
   Nonetheless, non-blocking I/O has garnered a strong following in
   the web development community, assessed by the popularity of server
   software like Python's Twisted, or Ruby's EventMachine. This is
   explained partly by the popularity of the language they are
   implemented in, partly by the performance they provide, and mostly
   by the convenience of their event-driven model for programmers.

   Since all the work with asynchronous I/O is done in callbacks, this
   directly translates into programming for events, a recurrent
   pattern of web programming. For instance, an HTTP server will have
   a function to handle a "request" event. Every request sent to the
   server will wake up Node, trigger this function, and send Node to
   sleep once the function has returned. It must be noted that since
   no threading is involved, the callbacks execute sequentially rather
   than concurrently. In particular, callbacks that are slow to return
   will become a bottleneck for the server scalability. Nevertheless,
   the event-driven approach is quite fit to the HTTP request/response
   model, as well as other network applications.

   Node also aims to be very modular: even core features are provided
   as modules lazily loadable in a server program. The WebSocket
   protocol is available in Node thanks to such modules. Spacewar uses
   the one named Socket.IO [ref]. While other modules expose the bare
   WebSocket protocol in Node, Socket.IO can fallback to other
   protocols (like AJAX, HTTP long polling or HTTP streaming) if the
   client has no support for WebSocket. This is highly convenient,
   given the discrepancies between browsers as well as between
   a browser's different versions.
     
* Inner workings

** Overview

*** The game rules and goal
    As previously stated, the intent in building Spacewar was to
    become more comfortable with standard and future web technologies,
    by creating a simple, yet engaging multiplayer game. The core
    gameplay revolves around shooting spaceships in space, with the
    added twist of compensating for the surrounding planets' gravity
    that draws spaceship fire.

    Browsing to the game server's URL immediately jumps the client
    into the game. Each player controls exactly one ship. The commands
    are simple: ships can rotate left or right, thrust forward, fire a
    bullet or use a bonus. Ships are brittle: one hit is all it takes
    to destroy them. Obstacles are plenty: planets, bullets, other
    ships, and lethal bonuses. The bright side is that dying bears no
    in-game penalty aside from losing any held bonuses, as hitting the
    spacebar immediately spawns a new ship. Hearing the opponent gloat
    over his victory is punishing enough.

    The action takes place on a rectangular map wrapped at the edges,
    effectively simulating a torus. A plain rectangular map with
    border walls is not symmetric: corners are notably disadvantageous
    for players who wander in them, since it is much harder to escape
    from them. The central area will thus see most of the action. A
    torus is symmetric action-wise, as all area have the same
    mobility. The toric map is harder to handle though, especially
    when considering collisions at the map borders, or when drawing it
    seamlessly in the client. The map is populated with immobile
    planets, which have two roles in the game. First they act as
    obstacles for players, as a ship colliding a planet will
    immediately turn to sidereal dust. Players can not blindly go
    forward, but must learn to maneuver skillfully between cluster of
    planets in order to survive. Secondly, planets affect the
    trajectory of bullets fired from the spaceships. Each planet has a
    gravity parameter proportional to its radius, and bullets are
    subject to every planet gravity field. Players have to learn how
    bullets react to gravity, as it is crucial to improve their aim
    but also to better dodge other ships' bullets.

    # Image of the map rectangle with infinity maps around and view
    # rectangles of some players.

    The game has no explicit goal other than enjoyment. Adding some
    kind of scoring system, based on the number of ships destroyed and
    length of survival would be trivial, but whether this is
    effectively beneficial to the game experience is still
    undetermined. The core formula has proved to be satisfying enough
    for the time being.

    The bonuses add variety to the game, by introducing new obstacles
    and weapons. New bonuses are regularly dropped onto the map,
    staying at their location until a ship picks it up by flying over
    it. Ships can only have one bonus at a time. Flying over a bonus
    when already holding one will replace it. Once picked up, a bonus
    can be used until it has no more charges. Most bonuses currently
    implemented have only one charge. Bonuses are not definitive, and
    need testing to determine if they have their place in the
    game. The upside is that bonuses are easily added and removed from
    a game for test purposes using parameters. Player feedback can be
    used to increase or decrease the probability of a certain type of
    bonus appearing. Ideally, these parameters could be altered even
    during a game, matching the current players' interests. The most
    successful bonus so far is the mine, immobile when placed on the
    map, but which explodes when a ship or a bullet enter its
    detection radius. These mines are a useful to set up traps against
    tailing opponents, or in tight planet clusters.

*** The decentralized prototype
    Spacewar is divided into a client and a server program. Both are
    written in CoffeeScript, compiled to JavaScript before being
    run. The client program is intended to be executed inside a web
    browser supporting the HTML canvas element. The server must be run
    by Node with additional modules installed.

    Historically, the initial prototype of Spacewar was meant to work
    without a server. The client handled all the game logic simulation,
    in addition to drawing, and one could play the game even if a
    server was not available. On the other hand, if a server was
    running, then clients would send it their position and bullets, and
    the server would broadcast them to all other connected clients. The
    server thus acted as a mere relay.

    This decentralized model had its merits: clients could play without
    a server, nearly all computation was offloaded to clients, thus
    greatly alleviating the server load, and the server was truly
    scalable, able to handle many clients since its only role was to
    coordinate packets between clients. But this approach was not
    devoid of problems. The first one was the game state
    synchronization across all clients. Since all clients ran their own
    game logic and only sent updates concerning their own actions, the
    game state was different for each one ; there was no authoritative
    state as in a centralized model. This allowed asymmetric situations
    to arise, where a ship would be dead for some clients but not for
    others. Although this might have been solvable, by acknowledging
    collisions between entities for affected clients for instance, the
    far greater issue of cheating remained.

    One thing to keep in mind with secure web development that also
    applies to games, is to never trust the client. The client, when
    given the chance, will always try to exploit any flaw to gain
    advantage. In a game setting, this amounts to cheating, which ruins
    the game experience of everyone else involved. This is not to say
    that all clients should be regarded as evil exploiters, as most are
    not, but care should be taken as to minimize, and even annihilate
    the risks. If by any means someone is able to gain an unfair
    advantage, then, given enough time, someone will. Manipulating the
    game code is made even easier with JavaScript browser games ; no
    decompilation is necessary as all the code is interpreted and
    embedded in the web page. With this in mind, letting clients make
    unilateral game decisions is ripe for exploits. In the Spacewar
    prototype, clients could easily change the ship maximum speed, to
    move faster than other players and gain advantage. The sole answer
    is to check all data received from clients, and drop faulty
    packets.

    Again, cheating is avoidable, game state synchronization is doable,
    but complexities and subtleties quickly arise when trying to solve
    both problems. The centralized model of a game server handling all
    game logic and broadcasting it to clients is far simpler to
    design. The choice was thus made early to switch Spacewar to this
    centralized model, at the cost of losing the ability for clients to
    play without a server, and greatly diminishing the scalability, but
    working as expected.

    - Server handles logic, communication
    - Client gathers input and draws

** Game logic

*** Update loop
    - Move
    - Check collisions
    - Update

*** Collisions
    - Spatial hashing
    - Symmetrical treatment

** Client-server communication
   - Keeping objects in sync
   - Minimizing communication overhead

*** Handling connections
*** Handling messages
*** Handling disconnections

** Drawing
   - DrawInfinity infinite tricks
   - Out of view checks
   - Clipping, double buffering
     

* Future improvements
 - Allow thousand game instances running on server cluster
 - Optimize client drawing
 - Optimize server update
 - Enhance compatibility with older browsers
 - Compatibility with touch devices

* Acknowledgments
  - Adrien, David, Thibaut for the spark
  - Merwan for the gas
  - Bertelle, Duvallet, Sanlaville.

* Links
** JavaScript
   - [[https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml][Google JavaScript Style Guide]], Aaron Whyte et al.
   - [[http://bonsaiden.github.com/JavaScript-Garden/][JavaScript Garden]], Ivo Wetzel and Zhang Yi Jiang, 2011.
   - [[http://coffeescript.org/][CoffeeScript]], Jeremy Ashkenas.

** WebSocket Protocol
  - [[http://tools.ietf.org/html/rfc6202][Known Issues and Best Practices for Long Polling]], April 2011
  - [[http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07][The WebSocket protocol standards draft]], April 22, 2011
  - [[http://dev.w3.org/html5/websockets/][The WebSocket API]], May 21, 2011
  - [[https://code.google.com/p/phpwebsocket/][phpwebsocket]], February 2010

** Node
   - http://nodejs.org/
   - [[http://socket.io][Socket.IO]]
   
** HTML5 drawing
  - [[http://webstuff.nfshost.com/anim-timing/Overview.html][Timing control for script-based animations]], February 22, 2011
  - [[http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element][HTML Standard: the canvas element]], May 27, 2011
  - [[http://www.khronos.org/registry/webgl/specs/latest/#7][WebGL Specification]], May 25, 2011
  - [[http://media.tojicode.com/q3bsp/][Quake 3 WebGL Demo]], Brandon Jones.
  - [[http://www.ro.me][ROME, "3 Dreams of Black"]], Chris Milk.

** HTML5 book
   http://diveintohtml5.org/

** HTM5 Polyfills
   https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
